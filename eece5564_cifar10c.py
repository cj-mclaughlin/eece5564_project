# -*- coding: utf-8 -*-
"""eece5564_cifar10c.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-ViwKXokDcnxQ1fgFabkCA8Y9A4G8S6P

## EECE 5564 Project

### Mid-project report deliverables

- List of initial experiments tried that were listed in the abstract
- List of new experiments and future plans
- 2 page max, ~1 page text ~1 page figures works
"""

# !wget https://zenodo.org/record/2535967/files/CIFAR-10-C.tar?download=1

"""### Download CIFAR10C"""

# !tar -xvf /content/CIFAR-10-C.tar?download=1

"""### Setup Dataloaders"""

# !ls

# DATA_PATH = "/content/CIFAR-10-C/"
DATA_PATH = "./CIFAR-10-C/"

from torchvision.datasets import CIFAR10
from torch.utils.data import DataLoader, Dataset
import torch
import numpy as np
from torchvision import transforms

CORRUPTED_CATEGORIES = [
    "brightness", "contrast", "defocus_blur", "elastic_transform", "fog",
    "frost", "gaussian_blur", "gaussian_noise", "glass_blur", "impulse_noise",
    "jpeg_compression", "motion_blur", "pixelate", "saturate", "shot_noise",
    "snow", "spatter", "speckle_noise", "zoom_blur"
]

CIFAR10_MEAN = [0.4913997551666284, 0.48215855929893703, 0.4465309133731618]
CIFAR10_STD = [0.24703225141799082, 0.24348516474564, 0.26158783926049628]

IMAGE_SIZE = 224, 224

train_transform = transforms.Compose([
    transforms.Pad(4, padding_mode='reflect'),
    transforms.RandomHorizontalFlip(),
    transforms.ToTensor(),
    transforms.Resize(IMAGE_SIZE),
    transforms.Normalize(mean=CIFAR10_MEAN, std=CIFAR10_STD)
])


test_transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Resize(IMAGE_SIZE),
    transforms.Normalize(mean=CIFAR10_MEAN, std=CIFAR10_STD)
])

class CIFAR10C(Dataset):
    """
    CIFAR10C Test Dataset: https://arxiv.org/abs/1903.12261

    args: provide a category [string] or simplely 'all' if for the entire dataset
    """
    def __init__(self, category="fog"):
        assert category in CORRUPTED_CATEGORIES + ['all']
        if category == 'all':
            self.data = np.concatenate([np.load(f"{DATA_PATH}{category}.npy") for category in CORRUPTED_CATEGORIES], axis=0)
            self.targets = np.tile(np.load(f"{DATA_PATH}/labels.npy"), reps=len(CORRUPTED_CATEGORIES))
        else:
            self.data = np.load(f"{DATA_PATH}{category}.npy")[40000:50000]
            self.targets = np.load(f"{DATA_PATH}/labels.npy")[40000:50000]

        self.transform = test_transform
        
    def __getitem__(self, index):
        x = self.data[index]
        y = self.targets[index]
        x = self.transform(x)
        return x, y
    
    def __len__(self):
        return len(self.data)

def cifar10_dataloaders(batch_size=32, num_workers=2):
    train_data = CIFAR10(root=DATA_PATH, download=True, train=True, transform=train_transform)
    test_data = CIFAR10(root=DATA_PATH, train=False, transform=test_transform)

    train_dataloader = DataLoader(train_data, batch_size=batch_size, shuffle=True, pin_memory=True, num_workers=num_workers, drop_last=True)
    test_dataloader = DataLoader(test_data, batch_size=batch_size, pin_memory=True, num_workers=num_workers)
    return train_dataloader, test_dataloader

def cifar10c_dataloaders(batch_size=32, num_workers=2, category='all'):
    dataset = CIFAR10C(category=category)
    dataloader = DataLoader(dataset, batch_size=batch_size, pin_memory=True, num_workers=num_workers)
    return None, dataloader

"""### Input Visualization

TODO visualize original images for the final report for potential figures
"""



"""### Feature Visualization

Using a pre-trained networks as feature extractors, we can visualize the class-conditional features with varying corruptions.

We could do some small comparison between different feature extractors, but that is probably not the focus of our work.

#### Load Model
"""

from torchvision.models import resnet18, resnet50

# model = resnet18(pretrained=True)
model =  resnet18(pretrained=True)
model.fc = torch.nn.Identity()  # remove FC layer for feature extraction
model.to("mps")
model.eval()

"""#### Data Loaders"""

# standard cifar10
cifar10_train, cifar10_test = cifar10_dataloaders()

# dataloader for each corruption in cifar10c
cifar10c = dict()
for corruption in CORRUPTED_CATEGORIES:
  _, cifar10c_test = cifar10c_dataloaders(category=corruption)
  cifar10c[corruption] = cifar10c_test

"""#### Extract Features

We will extract the features for each image, to be sorted by class label and corruptions
"""

from tqdm import tqdm
import pickle

with torch.no_grad():
    # standard cifar10
    cifar10_features = []
    cifar10_labels = []
    for image, label in tqdm(cifar10_test):
        image = image.to("mps")
        features = model(image).detach().cpu().numpy()
        cifar10_features.append(features)
        cifar10_labels.append(label.numpy())
    cifar10_features = np.concatenate(cifar10_features, axis=0)
    cifar10_labels = np.concatenate(cifar10_labels, axis=0)


with open('cifar10_features.pickle', 'wb') as handle:
    pickle.dump(cifar10_features, handle, protocol=pickle.HIGHEST_PROTOCOL)
  
with open('cifar10_labels.pickle', 'wb') as handle:
    pickle.dump(cifar10_labels, handle, protocol=pickle.HIGHEST_PROTOCOL)

with torch.no_grad():
    # cifar10c
    cifar10c_features = {
        corruption: [] for corruption in CORRUPTED_CATEGORIES
    }
    cifar10c_labels = {
        corruption: [] for corruption in CORRUPTED_CATEGORIES
    }
    for corruption in CORRUPTED_CATEGORIES:
        for image, label in tqdm(cifar10c[corruption]):
            image = image.to("mps")
            features = model(image).detach().cpu().numpy()
            cifar10c_features[corruption].append(features)
            cifar10c_labels[corruption].append(label.numpy())
        cifar10c_features[corruption] = np.concatenate(cifar10c_features[corruption], axis=0)
        cifar10c_labels[corruption] = np.concatenate(cifar10c_labels[corruption], axis=0)

with open('cifar10c_features_sev5.pickle', 'wb') as handle:
    pickle.dump(cifar10c_features, handle, protocol=pickle.HIGHEST_PROTOCOL)

with open('cifar10c_labels.pickle', 'wb') as handle:
    pickle.dump(cifar10c_labels, handle, protocol=pickle.HIGHEST_PROTOCOL)